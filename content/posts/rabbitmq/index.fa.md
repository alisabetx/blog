---
title: "کار با RabbitMQ"
slug: "rabbitmq"
date: 2025-02-12T14:00:00+03:30
lastmod: 2025-03-28T14:00:00+03:30
tags: ["rabbitmq", "message queue", "messaging", "ربیت ام کیو"]
description: "با ربیت‌ام‌کیو به صورت عملی کار کنیم"
---

# مفاهیم پایه {#basic-concepts}

به نرم افزارهایی مثل RabbitMQ میگن message broker یا queue manager. اینکه RabbitMQ یه پیام‌رسانه یعنی چی؟ یعنی پیام‌هایی که از ارسال‌کننده‌ها می‌گیره رو دریافت می‌کنه و تا زمانی که به دریافت‌کننده‌ها تحویل داده بشن، نگهشون میداره. البته نحوه ارسال، نگهداری و دریافت، همگی جزئیاتی دارن که باعث شده یک نرم افزار مجزا برای این مسئله ساخته بشه! پیام چیه؟ پیام میتونه یه متن ساده، دستورِ شروع یه پردازش یا هر چیز دیگه ای باشه.

به‌طور کلی، در دنیای Messaging، پابلیشر (یا producer) اون اپلیکیشنیه که پیام رو تولید می‌کنه و می‌فرسته. توی پروتکل‌های پیام‌رسانی، یه چیزی به اسم subscription داریم که به معنی دریافت پیام به صورت پایدار از سمت سرور هست. بعضی جاها بهش subscription می‌گن، بعضی جاها consumer میگن. RabbitMQ می‌گه consumer. ممکنه یه اپلیکیشن همزمان هم publisher باشه هم consumer.

یه message broker نقش واسطه رو بین چندتا سرویس مختلف بازی می‌کنه. اینا می‌تونن کمک کنن تا بار روی سرورهای اپلیکیشن کمتر بشه و زمان پاسخ‌دهی هم کاهش پیدا کنه، چون کارهایی که زمان‌بر یا منابع‌بر هستن رو می‌فرستن به یه سرویس دیگه که کار دیگه‌ای نداره جز انجام همون وظیفه.

اینجا یه سناریو رو دنبال می‌کنیم که توش یه وب‌اپلیکیشن اجازه می‌ده کاربر اطلاعاتش رو در قالب PDF دریافت کنه (مثلا اطلاعات تراکنشهای بانکی 6 ماه اخیرش رو بگیره). سایت قراره اطلاعات این کاربر رو پردازش کنه، یه PDF بسازه و اون رو ایمیل کنه به خود کاربر. پردازش اطلاعات، ساختن PDF و فرستادن ایمیل، چند ثانیه طول می‌کشه. این یکی از دلایلیه که برای انجام این کارها از message queue استفاده می‌کنیم.

وقتی کاربر درخواستش رو ثبت میکنه، وب‌اپلیکیشن یه پیام "پردازش PDF" می‌سازه که شامل همه اطلاعات کاربره و اون پیام رو می‌ذاره توی یه صف (queue) که توی RabbitMQ تعریف شده.

![workflow-rabbitmq](./images/workflow-rabbitmq.png#center)

ساختار پایه‌ای message queue ساده‌ست، یه سری اپلیکیشن به اسم producer وجود دارن که پیام می‌سازن و اون رو تحویل می‌دن به broker (یعنی همون message queue). یه سری اپلیکیشن دیگه به اسم consumer هم هستن که به صف وصل می‌شن و پیام‌ها رو می‌گیرن تا پردازش کنن. یه نرم‌افزار ممکنه فقط producer باشه، فقط consumer باشه، یا حتی همزمان هر دوتاش باشه. پیام‌هایی که توی صف قرار می‌گیرن، اونجا می‌مونن تا وقتی که یه consumer بیاد و برشون داره.

## چه زمانی و چرا RabbitMQ؟ {#چه-زمانی-و-چرا-rabbitmq}

استفاده از message queue باعث می‌شه سرورها بتونن سریع‌تر به درخواست‌ها پاسخ بدن، بدون اینکه مجبور باشن بلافاصله کارهای سنگین و منابع‌بر انجام بدن که ممکنه زمان پاسخ‌دهی رو زیاد کنه.

مصرف‌کننده (consumer) یه پیام رو از صف برمی‌داره و شروع می‌کنه به پردازش PDF. هم‌زمان، تولیدکننده (producer) داره پیام‌های جدیدی رو به صف اضافه می‌کنه. consumer می‌تونه روی یه سرور کاملاً جدا از producer باشه یا حتی روی همون سرور قرار گرفته باشن. ممکنه درخواست توی یه زبان برنامه‌نویسی ساخته بشه و توی یه زبان دیگه پردازش بشه. نکته‌ی مهم اینه که این دوتا اپلیکیشن فقط از طریق پیام‌هایی که می‌فرستن و می‌گیرن با هم ارتباط دارن؛ یعنی اتصال بینشون (coupling) خیلی کمه.

![rabbitmq-beginners-updated](./images/rabbitmq-beginners-updated.png#center)

1. کاربر یه درخواست ساخت PDF به وب‌اپلیکیشن می‌فرسته.
2. وب‌اپلیکیشن (که اینجا نقش producer رو داره) یه پیام به RabbitMQ می‌فرسته که شامل اطلاعاتی مثل اسم و ایمیل و اطلاعات تراکنش های بانکی کاربره.
3. یه exchange پیام‌ها رو از producer می‌گیره و به صف‌های مناسب برای ساخت PDF می‌فرسته.
4. ورکرِ پردازش PDF (که نقش consumer رو داره) پیام رو دریافت می‌کنه و شروع می‌کنه به ساختن PDF.

# اکسچنج‌ها (Exchanges) {#اکسچنجها-exchanges}

پیام‌ها مستقیماً توی صف (queue) قرار نمی‌گیرن؛ producer پیام رو به یه اکسچنج (exchange) می‌فرسته. وظیفه‌ی exchange اینه که پیام‌ها رو با کمک bindingها و routing keyها به صف‌های مختلف بفرسته. یه binding درواقع یه اتصال بین یه queue و یه exchange هست.

![exchanges-bidings-routing-keys](./images/exchanges-bidings-routing-keys.png#center)

جریان پیام در RabbitMQ به این صورته:

1. پابلیشر (Producer) یه پیام رو به یه exchange ارسال می‌کنه. موقع ساخت exchange، باید نوعش (type) مشخص شده باشه. (در مورد نوع exchange جلوتر صحبت می‌کنیم)
2. اکسچنج (Exchange) پیام رو دریافت می‌کنه و حالا وظیفه داره پیام رو هدایت کنه. بسته به نوع exchange، ویژگی‌های مختلفی از پیام (مثل routing key) برای مسیردهی بررسی می‌شن.
3. باید بین exchange و queueها یه سری binding تعریف بشه. توی این مثال، دوتا binding از exchange به دوتا queue مختلف داریم. exchange بر اساس ویژگی‌های پیام، تصمیم می‌گیره کدوم پیام به کدوم queue بره.
4. پیام‌ها توی queue می‌مونن تا وقتی که یه consumer بیاد و پردازششون کنه.
5. در نهایت، consumer پیام رو دریافت و هندل می‌کنه.

توضیحش با یه مثال ساده‌ی دنیای واقعی اینجوریه:

یه رستوران داریم. مشتری (که نقش **Producer** رو داره) سفارش غذا می‌ده. ولی سفارش مستقیم نمی‌ره توی آشپزخونه (یعنی **Queue**). اول می‌ره پیش پیشخدمت (که همون **Exchange** هست).

1. **مشتری (Producer)** سفارش می‌ده: «یه پیتزا لطفاً!»
2. **پیشخدمت (Exchange)** سفارش رو می‌گیره. بسته به نوع غذا (که همون **routing key** هست)، تصمیم می‌گیره این سفارش رو بده به کدوم بخش از آشپزخونه.
- اگه غذا پیتزا باشه، می‌فرستتش به صف پیتزا‌پزها (Queue مخصوص پیتزا).
- اگه غذا سالاد باشه، می‌فرستتش به صف سالادسازها (Queue مخصوص سالاد).
3. این اتصال بین پیشخدمت و هر بخش آشپزخونه رو **Binding** می‌گیم. یعنی یه قانون نوشتیم که مثلاً هر چی اسمش با "pizza" شروع می‌شه، بره سمت صف پیتزا.
4. سفارش ها توی **Queue** میمونن تا آشپز مربوطه بیاد و برشون داره.
5. آشپز که **Consumer** هست، پیام رو میخونه و اجراش میکنه، یعنی غذا رو آماده میکنه.

## انواع اکسچنج‌ها {#exchange-types}

- **مستقیم (Direct)**: پیام فقط به صف‌هایی فرستاده می‌شه که binding key دقیقاً با routing key پیام یکی باشه. مثلاً اگه یه صف با binding key به اسم pdfprocess به exchange وصل شده باشه، فقط پیامی که routing keyش pdfprocess باشه به این صف می‌ره.

- **فن‌اوت (Fanout)**: این نوع exchange پیام رو به همه صف‌هایی که بهش وصل هستن می‌فرسته، بدون توجه به routing key.

- **بر اساس تایپک (Topic)**: توی topic exchange می‌شه از wildcard استفاده کرد. یعنی می‌تونه routing key رو با الگوی تعریف‌شده توی binding مقایسه کنه (مثلاً *.pdf).

- **بر اساس هدر (Headers)**: توی این نوع exchange، بجای routing key، از مقادیر داخل header پیام برای مسیردهی استفاده می‌شه.

![exchanges-topic-fanout-direct](./images/exchanges-topic-fanout-direct.png#center)

# مرور چند مفهوم {#concept-review}

* **Producer**: اپلیکیشنی که پیام می‌فرسته.
* **Consumer**: اپلیکیشنی که پیام رو دریافت می‌کنه.
* **Queue**: یه بافر (صف) که پیام‌ها توش نگه داشته می‌شن.
* **Message**: اطلاعاتی که از producer به consumer فرستاده می‌شه، از طریق RabbitMQ.
* **Connection**: یه اتصال TCP بین اپلیکیشن تو و سرور RabbitMQ.
* **Channel**: یه اتصال مجازی داخل همون connection. وقتی پیام می‌فرستی یا مصرف می‌کنی، درواقع همه‌چیز داره از طریق همین کانال انجام می‌شه.
* **Exchange**: پیام‌ها رو از producer می‌گیره و طبق قوانینی که با نوع exchange تعریف شده، به صف‌ها می‌فرسته. برای اینکه پیام دریافت کنی، باید یه صف به حداقل یه exchange وصل شده باشه.
* **Binding**: اتصال بین یه queue و یه exchange.
* **Routing key**: یه کلید که exchange بهش نگاه می‌کنه تا تصمیم بگیره پیام به کدوم queue بره. مثل آدرس توی پیام.
* **AMQP**: پروتکلی که RabbitMQ برای انتقال پیام‌ها ازش استفاده می‌کنه (Advanced Message Queuing Protocol).
* **Vhost (Virtual Host)**: یه روش برای جدا کردن اپلیکیشن‌های مختلف توی یه سرور RabbitMQ. هر vhost می‌تونه queue، exchange و userهای مخصوص خودش رو داشته باشه.

# نصب {#installation}

برای سادگی و تمرکز روی مفاهیم اصلی RabbitMQ، از سرویس **CloudAMQP** استفاده می‌کنیم. دلیل این انتخاب اینه که نصب و کانفیگ کردن و نگهداری RabbitMQ روی سرور نیاز به دانش زیرساخت داره که موضوع این مبحث نیست و اینجا قراره as a developer ازش استفاده کنیم.

> توجه داشته باشید که در پروژه‌های واقعی، معمولاً RabbitMQ روی سرور داخلی یا زیرساخت ابری نصب و کانفیگ می‌شه تا امنیت، مقیاس‌پذیری و کنترل بیشتری داشته باشیم.

برای شروع در [CloudAMQP](https://www.cloudamqp.com/) ثبت نام کنید. در پنل کاربری، Create New Instance رو بزنید و پلن رو روی Little Lemur که از نوع RabbitMQ است بذارید و نام و تگ‌های دلخواهتون رو بهش بدید. در بخش Select a region and data center، یکی از گزینه‌هایی که در دسترس است رو انتخاب کنید، با توجه به اینکه هدف یادگیریه، روی این مسائل متمرکز نمی‌شیم. مشخصات Instance رو تایید کنید و با کلیک روی اون، وارد پنلش بشید.

ربیت‌ام‌کیو یه رابط کاربری تحت وب (Web UI) برای مدیریت و مانیتورینگ سرور RabbitMQ در اختیارتون می‌ذاره. این رابط مدیریتی به صورت پیش‌فرض توی CloudAMQP فعال شده و لینکش رو می‌تونید توی صفحه‌ی جزئیات instance توی CloudAMQP پیدا کنید.

![RabbitMQ-Panel](./images/RabbitMQ-Panel.png#center)

از طریق این رابط مدیریتی می‌تونید صف‌ها رو بسازید، پاک کنید، لیستشون رو ببینید یا مدیریت کنید. همچنین می‌تونید طول صف‌ها رو مانیتور کنید، نرخ پیام‌ها رو بررسی کنید، دسترسی کاربرها رو تغییر بدید یا کاربر جدید اضافه کنید و کلی کار دیگه.

# ارسال و دریافت پیام‌ها {#sending-receiving-messages}

ربیت‌ام‌کیو به صورت پیش‌فرض از پروتکلی به نام **AMQP** استفاده می‌کنه. برای اینکه اپلیکیشن‌ بتونه با RabbitMQ حرف بزنه، باید از یه کتابخونه استفاده کنیم که این پروتکل رو بفهمه. باید **کتابخونه‌ی کلاینت** مربوط به زبان برنامه‌نویسی‌ای که استفاده می‌کنی رو دانلود کنی. این کتابخونه در واقع یه API هست که باهاش می‌تونی کد کلاینت بنویسی. برای همه زبان‌های برنامه‌نویسی معروف یه نسخه از این کتابخونه‌ها وجود داره. اینجا قراره با سی شارپ و دات‌نت به RabbitMQ وصل بشیم.

## مراحل اتصال و ارسال/دریافت پیام {#connection-steps}

1. **ساخت/تنظیم connection**:
باید اطلاعاتی مثل نام کاربری، رمز عبور، URL اتصال، پورت و... رو مشخص کنی. بعد که متد `start` رو صدا بزنی، یه اتصال TCP بین اپلیکیشن و RabbitMQ برقرار می‌شه.

2. **ساختن channel روی اون connection**:
توی این connection، یه channel باز می‌کنی که پیام‌هات از طریق اون ارسال یا دریافت می‌شن.

3. **تعریف یا ساخت queue**:
وقتی یه صف رو declare کنی، اگه قبلاً وجود نداشته باشه ساخته می‌شه. قبل از اینکه بشه از یه صف استفاده کرد، باید declare شده باشه.

4. **تعریف exchange و وصل کردن queue به exchange در بخش subscriber/consumer**:
   همه‌ی exchangeها هم باید قبل از استفاده تعریف شده باشن. یه exchange پیام رو از اپلیکیشن producer می‌گیره و اون رو به queueها مسیردهی می‌کنه. ولی برای اینکه پیام‌ها واقعا به queue برسن، باید اون queue به exchange وصل (bind) شده باشه.

5. **در Publisher**: پیام رو به exchange ارسال کن.
6. **در Subscriber/Consumer**: پیام رو از queue دریافت کن.
7. **در پایان**: channel و connection رو ببند.

(ادامه دارد)

{{< edit >}}

# منابع {#resources}
[RabbitMQ](https://rabbitmq.com/)
[CloudAMQP](https://cloudamqp.com/)